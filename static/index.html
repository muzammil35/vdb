<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Override PDF.js default styles */
        .page {
            position: relative;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background: white;
        }
        
        .page canvas {
            display: block;
        }
        
        /* Text layer styling */
        .textLayer {
            opacity: 0.2;
        }
        
        .textLayer ::selection {
            background: rgba(0, 123, 255, 0.3);
        }
        
        /* Search highlights - using PDF.js classes */
        .textLayer .highlight {
            background-color: rgba(255, 140, 0, 0.6);
            border-radius: 2px;
        }

        .backend-highlight {
            background: rgba(255, 140, 0, 0.6);
            border-radius: 2px;
        }

        .post-match-highlight {
            background: rgba(255, 140, 0, 0.6); /* light blue */
            border-radius: 2px;  
        }
        
        .textLayer .highlight.selected {
            background-color: rgba(255, 140, 0, 0.6);
            border-radius: 2px;
        }
        
        #viewerContainer {
            position: absolute;
            overflow: auto;
            width: 100%;
            top: 80px;
            bottom: 0;
        }
        
        #viewer {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
        }
        
        #search-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: white;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="bg-gray-100">
    <div id="search-bar">
        <div class="container mx-auto flex gap-2 items-center">
            <input 
                type="text" 
                id="search-input" 
                placeholder="Search in PDF..." 
                class="flex-1 border rounded px-3 py-2"
            />
            <button 
                id="prev-match" 
                class="bg-blue-500 text-white px-3 py-2 rounded hover:bg-blue-600 disabled:bg-gray-300"
                disabled
            >
                ← Previous
            </button>
            <button 
                id="next-match" 
                class="bg-blue-500 text-white px-3 py-2 rounded hover:bg-blue-600 disabled:bg-gray-300"
                disabled
            >
                Next →
            </button>
            <span id="match-counter" class="text-sm text-gray-600 min-w-[100px]"></span>
            <select id="zoom-select" class="border rounded px-2 py-1 text-sm">
                <option value="0.5">50%</option>
                <option value="0.75">75%</option>
                <option value="1">100%</option>
                <option value="1.5" selected>150%</option>
                <option value="2">200%</option>
            </select>
        </div>
    </div>

    <div id="viewerContainer">
        <div id="loading" class="text-center py-8">
            <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900"></div>
            <p class="mt-4 text-gray-600">Loading PDF...</p>
        </div>
        <div id="viewer" class="pdfViewer"></div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 
            'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Initialize EventBus for coordinating viewer components
        const eventBus = new pdfjsViewer.EventBus();
        
        // Create link service for navigation
        const pdfLinkService = new pdfjsViewer.PDFLinkService({
            eventBus: eventBus,
        });

        // Create PDF viewer
        const pdfViewer = new pdfjsViewer.PDFViewer({
            container: document.getElementById('viewerContainer'),
            viewer: document.getElementById('viewer'),
            eventBus: eventBus,
            linkService: pdfLinkService,
            textLayerMode: 1, // 0=disable, 1=enable, 2=enable enhanced
            removePageBorders: false,
        });

        pdfLinkService.setViewer(pdfViewer);
        
        console.log('PDFViewer initialized with textLayerMode:', pdfViewer.textLayerMode);

        // UI elements
        const searchInput = document.getElementById('search-input');
        const prevButton = document.getElementById('prev-match');
        const nextButton = document.getElementById('next-match');
        const matchCounter = document.getElementById('match-counter');
        const zoomSelect = document.getElementById('zoom-select');
        const loading = document.getElementById('loading');

        let currentMatchIndex = 0;
        let totalMatches = 0;
        let pdfFindController = null;
        let pagesReady = 0;
        let backendMatches = []; // top 5 matches from backend
        let currentSearchQuery = ''; // Store the original query
        let pdfDocument = null;
        const pageTextIndex = new Map(); // pageNumber -> { fullText, items, offsetMap }
        // Load PDF
        async function loadPDF() {
            try {

                // Create find controller after document is loaded
                pdfFindController = new pdfjsViewer.PDFFindController({
                    eventBus: eventBus,
                    linkService: pdfLinkService,
                    pdfViewer: pdfViewer,
                });

                // Set the find controller on the viewer BEFORE loading
                pdfViewer.findController = pdfFindController;

                const loadingTask = pdfjsLib.getDocument('/api/pdf');
                pdfDocument = await loadingTask.promise;
                
                pdfViewer.setDocument(pdfDocument);
                pdfLinkService.setDocument(pdfDocument);
                pdfFindController.setDocument(pdfDocument);

                
                loading.style.display = 'none';
                
                // Set initial scale
                pdfViewer.currentScaleValue = '1.5';
                
                console.log('PDF loaded, total pages:', pdfDocument.numPages);
            } catch (error) {
                console.error('Error loading PDF:', error);
                loading.innerHTML = '<p class="text-red-600">Error loading PDF</p>';
            }
        }

        // Search functionality
        let searchTimeout = null;
        
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                const query = e.target.value.trim();
                
                if (!query) {
                    // Clear search
                    if (pdfFindController) {
                        eventBus.dispatch('findbarclose');
                    }
                    updateMatchCounter(0, 0);
                    backendMatches = [];
                    currentSearchQuery = '';
                    return;
                }

                // Wait a bit more for text layers to be ready
                if (pagesReady < 1) {
                    console.log('Waiting for pages to render...');
                    setTimeout(() => {
                        performSearch(query);
                    }, 500);
                } else {
                    performSearch(query);
                }
            }, 300); // Debounce search
        });
        
        async function performSearch(query) {
            console.log('Searching for:', query, 'Pages ready:', pagesReady);
            
            // Store the original query for highlighting
            currentSearchQuery = query;

            console.log('Calling backend search for:', query);

            try {
                const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`);
                if (!response.ok) throw new Error('Network response was not ok');

                const results = await response.json(); // expected: [{page, text}]
                console.log('Backend matches:', results);

                // Take top 5 matches
                backendMatches = results.slice(0, 5);
                currentMatchIndex = 0;

                if (backendMatches.length === 0) {
                    updateMatchCounter(0, 0);
                    return;
                }

                // Start highlighting the first backend match
                highlightCurrentBackendMatch();

            } catch (error) {
                console.error('Error fetching backend search results:', error);
                updateMatchCounter(0, 0);
            }
        }

        async function highlightCurrentBackendMatch() {
            if (!pdfFindController || backendMatches.length === 0) return;

            const match = backendMatches[currentMatchIndex];

            console.log('Navigating to page:', match.page);
            console.log('Chunk text:', match.text.substring(0, 100) + '...');

            // Scroll to page
            pdfViewer.scrollPageIntoView({ pageNumber: match.page });

            // Extract first 3 words ONLY
            const words = match.text.trim().split(/\s+/);
            const first3 = words.slice(0, 3).join(' ');

            console.log('Searching for first words:', first3);

            // Give PDF.js a moment to render the page
            setTimeout(() => {
                eventBus.dispatch('find', {
                    type: 'find',
                    query: first3,
                    caseSensitive: false,
                    entireWord: false,
                    highlightAll: false, // important
                    findPrevious: false,
                });
            }, 150);

            updateMatchCounter(currentMatchIndex + 1, backendMatches.length);
        }

        function highlightFromMatchToEndOfPage() {
            const selected = document.querySelector('.highlight.selected');
            if (!selected) return;

            const pageDiv = selected.closest('.page');
            if (!pageDiv) return;

            const textLayer = pageDiv.querySelector('.textLayer');
            if (!textLayer) return;

            // Get ALL spans in the text layer
            const spans = Array.from(textLayer.querySelectorAll('span'));
            
            // Find which span contains or comes after the selected highlight
            let startIndex = -1;
            for (let i = 0; i < spans.length; i++) {
                const span = spans[i];
                // Check if this span contains the highlight or comes after it
                if (span.contains(selected) || span.querySelector('.highlight.selected')) {
                    startIndex = i;
                    break;
                }
            }

            if (startIndex === -1) return;

            // Remove old highlights
            textLayer.querySelectorAll('.post-match-highlight')
                .forEach(el => el.classList.remove('post-match-highlight'));

            // Add highlight class up to max 500 characters
            let charCount = 0;
            const maxChars = 500;
            
            for (let i = startIndex; i < spans.length; i++) {
                const spanText = spans[i].textContent;
                const remainingChars = maxChars - charCount;
                
                if (charCount >= maxChars) {
                    break;
                }
                
                if (charCount + spanText.length <= maxChars) {
                    // Highlight entire span
                    spans[i].classList.add('post-match-highlight');
                    charCount += spanText.length;
                } else {
                    // Partial highlight - only highlight remaining chars
                    spans[i].classList.add('post-match-highlight');
                    charCount = maxChars;
                    break;
                }
            }
        }

        function highlightFromMatchToEndOfPage_() {
            const selected = document.querySelector('.highlight.selected');
            if (!selected) return;

            const pageDiv = selected.closest('.page');
            if (!pageDiv) return;

            const textLayer = pageDiv.querySelector('.textLayer');
            if (!textLayer) return;

            // Get ALL spans in the text layer (not just direct children)
            const spans = Array.from(textLayer.querySelectorAll('span'));
            
            // Find which span contains the selected highlight
            let startSpan = null;
            for (const span of spans) {
                if (span.contains(selected) || span === selected) {
                    startSpan = span;
                    break;
                }
            }

            if (!startSpan) return;
            
            const startIndex = spans.indexOf(startSpan);
            if (startIndex === -1) return;

            // Remove old highlights
            textLayer.querySelectorAll('.post-match-highlight')
                .forEach(el => el.classList.remove('post-match-highlight'));

            // Highlight from the SAME span onward (including the matched words)
            for (let i = startIndex; i < spans.length; i++) {
                // Don't override the selected highlight styling
                spans[i].classList.add('post-match-highlight');
                
            }
        }

        function highlightFromMatchToEndOfPage_() {
            const selected = document.querySelector('.highlight.selected');
            if (!selected) return;

            const pageDiv = selected.closest('.page');
            if (!pageDiv) return;

            const textLayer = pageDiv.querySelector('.textLayer');
            if (!textLayer) return;

            const spans = Array.from(textLayer.querySelectorAll('span'));
            
            // Find which span contains the selected highlight
            let startSpan = null;
            for (const span of spans) {
                if (span.contains(selected) || span === selected) {
                    startSpan = span;
                    break;
                }
            }

            if (!startSpan) return;
            
            const startIndex = spans.indexOf(startSpan);
            if (startIndex === -1) return;

            // Remove old highlights
            textLayer.querySelectorAll('.post-match-highlight')
                .forEach(el => el.remove());

            // Get the text content after the selected match
            const selectedText = selected.textContent;
            const spanText = startSpan.textContent;
            const matchEndIndex = spanText.indexOf(selectedText) + selectedText.length;
            
            // Highlight remaining text in the same span
            if (matchEndIndex < spanText.length) {
                const remainingText = spanText.substring(matchEndIndex);
                const highlight = document.createElement('span');
                highlight.className = 'post-match-highlight';
                highlight.textContent = remainingText;
                
                // Split the span content
                startSpan.textContent = spanText.substring(0, matchEndIndex);
                startSpan.parentNode.insertBefore(highlight, startSpan.nextSibling);
            }

            // Highlight all following spans by wrapping their content
            for (let i = startIndex + 1; i < spans.length; i++) {
                const span = spans[i];
                if (span.textContent.trim()) {
                    const highlight = document.createElement('span');
                    highlight.className = 'post-match-highlight';
                    highlight.textContent = span.textContent;
                    span.textContent = '';
                    span.appendChild(highlight);
                }
            }
        }



        // Listen for search results
        eventBus.on('updatefindmatchescount', (e) => {
            console.log('Match count update:', e);
        });

        let lastScrolledMatch = null;

        function scrollIntoViewIfNotVisible(highlighted) {
            if (!highlighted || highlighted === lastScrolledMatch) return;

            const container = document.getElementById('viewerContainer');
            const elementRect = highlighted.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();

            const isVisible =
                elementRect.top >= containerRect.top &&
                elementRect.bottom <= containerRect.bottom;

            if (!isVisible) {
                highlighted.scrollIntoView({ block: 'center', behavior: 'smooth' });
                lastScrolledMatch = highlighted;
            }
        }

        eventBus.on('updatefindcontrolstate', (e) => {
            console.log('Find control state:', e);
            
            if (e.state === pdfjsViewer.FindState.FOUND) {
                setTimeout(() => {
                    const highlighted = document.querySelector('.highlight.selected');
                    if (highlighted) {
                        scrollIntoViewIfNotVisible(highlighted);
                    }
                    highlightFromMatchToEndOfPage();
                }, 100);
            } else if (e.state === pdfjsViewer.FindState.NOT_FOUND) {
                console.warn('Text not found on page');
            }
        });

        function updateMatchCounter(current, total) {
            if (total === 0) {
                matchCounter.textContent = searchInput.value.trim() ? 'No matches' : '';
                prevButton.disabled = true;
                nextButton.disabled = true;
            } else {
                matchCounter.textContent = `${current} / ${total}`;
                prevButton.disabled = current <= 1;
                nextButton.disabled = current >= total;
            }
        }

        prevButton.addEventListener('click', () => {
            if (backendMatches.length === 0) return;

            currentMatchIndex = Math.max(0, currentMatchIndex - 1);
            highlightCurrentBackendMatch();
        });

        nextButton.addEventListener('click', () => {
            if (backendMatches.length === 0) return;

            currentMatchIndex = Math.min(backendMatches.length - 1, currentMatchIndex + 1);
            highlightCurrentBackendMatch();
        });


        // Keyboard shortcuts
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    prevButton.click();
                } else {
                    nextButton.click();
                }
            } else if (e.key === 'Escape') {
                searchInput.value = '';
                eventBus.dispatch('findbarclose');
                updateMatchCounter(0, 0);
                backendMatches = [];
                currentSearchQuery = '';
            }
        });

        // Zoom control
        zoomSelect.addEventListener('change', (e) => {
            pdfViewer.currentScaleValue = e.target.value;
            
            // Re-run search if active
            if (pdfFindController && currentSearchQuery) {
                setTimeout(() => {
                    eventBus.dispatch('find', {
                        type: 'find',
                        query: currentSearchQuery,
                        caseSensitive: false,
                        entireWord: false,
                        highlightAll: true,
                        findPrevious: false,
                    });
                }, 100);
            }
        });

        // Handle pages being rendered
        eventBus.on('pagerendered', (e) => {
            pagesReady++;
        });
        
        // Handle text layer rendered
        eventBus.on('textlayerrendered', (e) => {
        });

        // Load the PDF on page load
        loadPDF();
    </script>
</body>
</html>